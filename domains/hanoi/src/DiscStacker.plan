/*************************************************************
 * This file is generated by the JACK Development Environment.
 * Saved at: Thu Feb 21 17:28:43 EST 2002
 * WARNING: DO NOT EDIT THIS OR YOUR CHANGES MAY BE LOST
 *************************************************************/

import gui.Towers;

/* Documentation */

/**
   This is the main strategy used to stack discs. In short, this strategy
   is: stack the discs on pin 2, starting from the larger (#1) to end with 
   the smaller (#9). (Remember that, the larger a disc number, the smaller 
   the disc is).
*/

public plan DiscStacker extends Plan {

    #handles event StackDisc ev;
	#uses interface Player ag;

    static boolean
    relevant(StackDisc ev)
    {
        return true;
    }
    
    #posts event SolveDisc sd;
    #reads data Towers window;
    #reads data Order order;
    #reads data Top top;
    #reads data Place place;

    context()
    {
        true;
    }
    
    #reasoning method
    body()
    {
        if (ag.demoMode) {
            logical int pin;
            pin.unify(2);
            for (int i = 1;(i < ag.numDiscs+1);i++ ){
                logical int disc;
                disc.unify(i);
                printStack();
                ag.writeLog("Solving for disc "+disc+" onto pin "+ pin);
                if (window.visibleMode()) {
                    window.setCaption("Solving disc"+disc+" to pin"+ pin);
                }
                @subtask(sd.solve(disc,pin,ag.maxRecursion,ag.tops(),ag.places()));
                ag.writeLog(((("Stacked disc " + disc) + " onto pin ") + pin));
            }
            if (window.visibleMode()) {
                window.setCaption("Solved!"+ pin);
            }
        } else {
            logical int pin;
            logical int pL;
            int pI;
            logical int disc;
            disc.unify(1+ag.generator.nextInt(ag.numDiscs));
            place.get(pL,disc);
            while ((pI = ag.generator.nextInt(ag.numPins)) == pL.as_int());
            pin.unify(pI);
            ag.writeLog("EPISODE "+ag.episode+"--------------------");
            if (window.visibleMode()) {
                window.setCaption("Episode "+ag.episode+": Solving disc"+disc+" to pin"+ pin);
            }
            printStack();
            
            @subtask(sd.solve(disc,pin,ag.maxRecursion,ag.tops(),ag.places()));
        }
    }

    #reasoning method
    pass()
    {
        ag.writeLog("PASSED");
        ag.writeResult(ag.episode,true);
    }

    #reasoning method
    fail()
    {
        ag.writeLog("FAILED");
        ag.writeResult(ag.episode,false);
    }

    #reasoning method
    printStack()
    {
        for (int pin = 0;(pin < 3);pin++ ){
            logical int disc;
            String s = "Pin " + pin + " - top to bottom: ";
            top.get(pin,disc);
            for (int i = disc.getValue();(i > 0);){
                logical int j;
                s += " " + i;
                order.get(i,j);
                i = j.getValue();
            }
            ag.writeLog(s);
        }
    }
}

