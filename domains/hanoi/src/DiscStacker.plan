/*************************************************************
 * This file is generated by the JACK Development Environment.
 * Saved at: Thu Feb 21 17:28:43 EST 2002
 * WARNING: DO NOT EDIT THIS OR YOUR CHANGES MAY BE LOST
 *************************************************************/

import java.util.Vector;
import gui.Towers;

/* Documentation */

/**
   This is the main strategy used to stack discs. In short, this strategy
   is: stack the discs on pin 2, starting from the larger (#1) to end with 
   the smaller (#9). (Remember that, the larger a disc number, the smaller 
   the disc is).
*/

public plan DiscStacker extends Plan {

    #handles event StackDisc ev;
	#uses interface Player ag;

    static boolean
    relevant(StackDisc ev)
    {
        return true;
    }
    
    #posts event SolveDisc sd;
    #reads data Towers window;
    #reads data Order order;
    #reads data Top top;
    #reads data Place place;

    context()
    {
        true;
    }
    
    #reasoning method
    body()
    {
        if (ag.demoMode()) {
            logical int pin;
            pin.unify(2);
            for (int i = 1;(i < ag.numDiscs()+1);i++ ){
                logical int disc;
                disc.unify(i);
                printStack();
                ag.writeLog("Solving for disc "+disc+" onto pin "+ pin);
                if (window.visibleMode()) {
                    window.setCaption("Solving disc"+disc+" to pin"+ pin);
                }
                @subtask(sd.solve(disc,pin,ag.maxRecursion(),ag.discsOnTop(),ag.places()));
                ag.writeLog(((("Stacked disc " + disc) + " onto pin ") + pin));
            }
            if (window.visibleMode()) {
                window.setCaption("Solved!"+ pin);
            }
        } else {
            logical int pin;
            logical int disc;
            ag.writeLog("EPISODE "+ag.episode()+"--------------------");
            String goalKey = ag.getGoalKeyThisEpisode();
            if (ag.initSupplied() && (goalKey != null)) {
                String[] vals = goalKey.split(",");
                disc.unify(Integer.parseInt(vals[0]));
                pin.unify(Integer.parseInt(vals[1]));
            } else {
                logical int pL;
                int pI;
                disc.unify(1+ag.generator().nextInt(ag.numDiscs()));
                place.get(pL,disc);
                while ((pI = ag.generator().nextInt(ag.numPins())) == pL.as_int());
                pin.unify(pI);
            }
            if (window.visibleMode()) {
                window.setCaption("Episode "+ag.episode()+": Solving disc"+disc+" to pin"+ pin);
            }
            printStack();
            ag.setGoalKeyThisEpisode(Integer.toString(disc.getValue())+","+Integer.toString(pin.getValue()));
            @subtask(sd.solve(disc,pin,ag.maxRecursion(),ag.discsOnTop(),ag.places()));
        }
    }

    #reasoning method
    pass()
    {
        ag.writeLog("PASSED");
        ag.writeResult(ag.episode(),true);
    }

    #reasoning method
    fail()
    {
        ag.writeLog("FAILED");
        ag.writeResult(ag.episode(),false);
    }

    #reasoning method
    printStack()
    {
        for (int pin = 0;(pin < 3);pin++ ){
            logical int disc;
            String s = "Pin " + pin + " - top to bottom: ";
            top.get(pin,disc);
            for (int i = disc.getValue();(i > 0);){
                logical int j;
                s += " " + i;
                order.get(i,j);
                i = j.getValue();
            }
            ag.writeLog(s);
        }
    }
}

