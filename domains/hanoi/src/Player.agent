/*************************************************************
 * This file is generated by the JACK Development Environment.
 * Saved at: Thu Feb 21 17:28:43 EST 2002
 * WARNING: DO NOT EDIT THIS OR YOUR CHANGES MAY BE LOST
 *************************************************************/

import aos.util.Properties;
import aos.jack.jak.beliefset.BeliefSetException;

import java.util.*;
import java.io.PrintWriter;
import java.io.IOException;
import java.io.Serializable;
import java.io.ObjectOutputStream;
import java.io.FileOutputStream;

import trees.Logger;
import trees.Tree;
import trees.Node;

import agents.PlanNode;
import agents.GoalNode;
import agents.Config.PlanSelectMode;
import agents.Config.UpdateMode;

import weka.core.FastVector;
import weka.core.Attribute;

import gui.Towers;

/* Documentation */

/**
   The Player agent solves the Towers of Hanoi puzzle.
   It has three capabilities:
   - DiscStacking, which includes initialising the puzzle and then
         provide the solution strategy;
   - Solving, which includes plans for solving the puzzle, i.e. which
         move to do next;
   - DiscMoving, which deals with actually moving discs.
**/

public agent Player extends Agent implements Logger{
    #private data Order order();
    #private data Top top();
    #private data Place place();
    #private data Towers window("Towers of Hanoi");
    #has capability DiscStacking stacking;
    #has capability Solving solving;
    #has capability DiscMoving moving;
    #posts event StackingStart ss;
	#uses plan MetaPlan;
	#handles event PlanChoice;
    
    private int numDiscs;
    private int numPins;

    private boolean learningMode;
    private boolean demoMode  = false;
    
    private int episode = 0;
    private int maxEpisodes = 0;
    private int maxRecursion = 0;
    
    private PlanSelectMode pselect;
    
    private String targetDir;
    private String filename;
    
    private Random generator;
    private Random selector;
    private PrintWriter writerOut;
    private PrintWriter writerRes;
    
    private HanoiState init;
    private String episodeGoalKey;
    private Integer[] episodeStartState;
    private int maxDepthThisEpisode;
    private boolean saveInitStates;
    
    private int indent = 0;
    
	Tree gpTree;
    public PlanNode[] planNodes;

    // Constructor
    Player(int nDiscs, boolean visible, boolean learning, int episodes, int recursion, PlanSelectMode pselect, UpdateMode uselect, int minInstances, int stableK, double stableE, String targetDir, String filename, long seed, boolean saveInit) {
        super("player");
        
        this.init = new HanoiState(nDiscs);
        this.episodeStartState = null;
        this.episodeGoalKey = "";
        this.maxDepthThisEpisode = 0;
        this.saveInitStates = saveInit;
        
        this.numDiscs = nDiscs;
        this.numPins = 3;
        
        this.pselect = pselect;
        this.maxRecursion = recursion;
        generator = (seed == 0) ? new Random() : new Random(seed);
        selector = new Random();
        
        this.targetDir = targetDir;
        this.filename = filename;
        
        try{
            writerOut = new PrintWriter(targetDir + "/player.out");
            writerRes = new PrintWriter(targetDir + "/" + filename);
        }catch(IOException e){
            System.err.println("Error opening the file for writing the outcome \n"+e);
            System.exit(9);
        }
        
        episode = 0;
        maxEpisodes = episodes;
        learningMode = learning;
        if (learningMode) {
            initLearning((trees.Logger)this, numDiscs, numPins, recursion, pselect, uselect, minInstances, stableK, stableE);
        }

        newRandomOrder();
        
        if (visible) {
            window.initFrame();
        }
    }

    public void setMaxDepthThisEpisode(int depth) {
        maxDepthThisEpisode = depth;
    }

    public int maxDepthThisEpisode() {
        return maxDepthThisEpisode;
    }

    public int maxRecursion() {
        return maxRecursion;
    }

    public int maxEpisodes() {
        return maxEpisodes;
    }

    public int numDiscs() {
        return numDiscs;
    }

    public int numPins() {
        return numPins;
    }

    public int episode() {
        return episode;
    }

    public boolean learningMode() {
        return learningMode;
    }

    public boolean demoMode() {
        return demoMode;
    }

    public Random generator() {
        return generator;
    }

    public Random selector() {
        return selector;
    }

    public PlanSelectMode pselect() {
        return pselect;
    }

    public void finishEpisode() {
        indentReset();
        if (saveInitStates) {
            saveInitState();
        }
        newRandomOrder();
        episode++;
        maxDepthThisEpisode = 0;
    }
    
    public void setGoalKeyThisEpisode(String key) {
        episodeGoalKey = key;
    }
    
    public void saveInitState() {
        String key = episodeGoalKey+","+maxDepthThisEpisode;
        writeLog("Storing initial hanoi state for key["+key+"]");
        init.set(key, episodeStartState);
    }
    

    public void newRandomOrder() {
        try {
            order.deleteAll();
            int[] tops = new int[3];
            tops[0] = 0;
            tops[1] = 0;
            tops[2] = 0;
            for (int i = 1; i <= numDiscs; i++) {
                int r = generator.nextInt(3);
                order.add(i,tops[r]);
                tops[r] = i;
            }
            
            episodeStartState = new Integer[numDiscs];
            for (int i = 0; i < numDiscs; i++) {
                episodeStartState[i]=new Integer(order.getBelow(i));
            }
        } catch (Exception e) {
            System.err.println("Error initialising the order of discs on the pins\n"+e);
            System.exit(9);
        }
    }
    
    Integer[] tops() {
        Integer[] t = new Integer[numPins];
        for (int i = 0; i < t.length; i++) {
            try{
                t[i] = new Integer(top.get(i));
            } catch (BeliefSetException e) {
                System.err.println("Error accessing belief top.get("+i+")\n"+e);
                System.exit(9);
            }
        }
        return t;
    }

    Integer[] places() {
        Integer[] p = new Integer[numDiscs];
        for (int i = 1; i <= p.length; i++) {
            try{
                p[i-1] = new Integer(place.get(i));
            } catch (BeliefSetException e) {
                System.err.println("Error accessing belief place.get("+i+")\n"+e);
                System.exit(9);
            }
        }
        return p;
    }

    Integer[] discsOnTop() {
        Integer[] n = new Integer[numDiscs];
        for (int i = 1; i <= n.length; i++) {
            try{
                int top = i;
                int count = -1;
                do {
                    top = order.get(top);
                    count++;
                } while (top != -1);
                n[i-1] = new Integer(count);
            } catch (BeliefSetException e) {
                System.err.println("Error accessing belief place.get("+i+")\n"+e);
                System.exit(9);
            }
        }
        return n;
    }

    public PlanIdInfo planInfo(int pid, String[] state, int level, int rec) {
        if (learningMode) {
            PlanNode thisNode = planNodes[pid];
            //int nodeComplexity = 1 + selector.nextInt(rec);
            int nodeComplexity = rec;
            nodeComplexity = nodeComplexity * nodeComplexity;
            double confidence = Math.min(1.0,thisNode.countForClassification(state)/nodeComplexity);
            if (thisNode.useDT(1/*Iteration: not used*/)){
                double[] ps = thisNode.getProbability(state);
                return new PlanIdInfo(pid, ps[0], confidence, 1.0, false);
            } else{
                return new PlanIdInfo(pid, 0.5, confidence, 1.0, false);
            }
        } else {
            return new PlanIdInfo(pid, 0.5, 1.0, 1.0, false);
        }
    }

    public void go() {
        postEvent(ss.start(true));
    }

    public void finish() {
        if (learningMode) {
            for (int i = 0; i < planNodes.length; i++) {
                writeLog(planNodes[i].getDT());
            }
        }
        if (saveInitStates) {
            try {
                String filename = targetDir + "/player.init";
                ObjectOutputStream writerObj = new ObjectOutputStream(new FileOutputStream(filename));
                writerObj.writeObject(init);
                writerObj.close();
                writeLog("Saved "+init.size()+" initial hanoi states to file " + filename);
            } catch (Exception e) {
                System.err.println("Error saving initial states: "+e);
            }
        }
        writerOut.close();
        writerRes.close();
    }
    
    public void indentRight() {
        indent++;
    }

    public void indentLeft() {
        indent--;
    }
    
    public void indentReset() {
        indent=0;
    }

    public void writeLog(String str) {
        String s = "";
        for (int i = 0;(i < indent);i++ ) s+= " ";
        writerOut.println(s + str);
        writerOut.flush();
    }
    public void writeResult(int episode, boolean result) {
        String str = episode + (result ? " 1.0 0.0" : " 0.0 1.0");
        writerRes.println(str);
        writerRes.flush();
    }
    
    public void initLearning(Logger logger, int nDiscs, int nPins, int recursion, PlanSelectMode pselect, UpdateMode uselect, int minInstances, int stableK, double stableE) {
        FastVector classVal = new FastVector();
        classVal.addElement("+");
        classVal.addElement("-");

        FastVector bval = new FastVector();
        bval.addElement("T");
        bval.addElement("F");

        FastVector dval = new FastVector();
        for (int i = 0; i < nDiscs+1; i++) {
            dval.addElement(Integer.toString(i));
        }

        FastVector pval = new FastVector();
        for (int i = 0; i < 3; i++) {
            pval.addElement(Integer.toString(i));
        }

        FastVector rval = new FastVector();
        for (int i = 0; i < recursion; i++) {
            rval.addElement(Integer.toString(i));
        }
        
        FastVector atts = new FastVector();
        atts.addElement(new Attribute("disc"));
        atts.addElement(new Attribute("pin",pval));
        //atts.addElement(new Attribute("recursionLevel",rval));
        
        //for (int i = 0; i < nPins; i++) {
        //    atts.addElement(new Attribute("topDiscOnPin"+i));
        //}
        for (int i = 1; i <= nDiscs; i++) {
            atts.addElement(new Attribute("discsOnTopOf"+i));
        }
        for (int i = 1; i <= nDiscs; i++) {
            atts.addElement(new Attribute("pinOfDisc"+i,pval));
        }

        atts.addElement(new Attribute("outcome",classVal));
    

        planNodes = new PlanNode[5];
        planNodes[0] = new PlanNode(new Integer(0),"P0", atts, classVal, dval, minInstances, uselect, PlanSelectMode.PROBABILISTIC/*pselect*/, stableE, stableK, false, logger);
        planNodes[1] = new PlanNode(new Integer(1),"P1", atts, classVal, dval, minInstances, uselect, PlanSelectMode.PROBABILISTIC/*pselect*/, stableE, stableK, false, logger);
        planNodes[2] = new PlanNode(new Integer(2),"P2", atts, classVal, dval, minInstances, uselect, PlanSelectMode.PROBABILISTIC/*pselect*/, stableE, stableK, false, logger);
        planNodes[3] = new PlanNode(new Integer(3),"P3", atts, classVal, dval, minInstances, uselect, PlanSelectMode.PROBABILISTIC/*pselect*/, stableE, stableK, false, logger);
        planNodes[4] = new PlanNode(new Integer(4),"P4", atts, classVal, dval, minInstances, uselect, PlanSelectMode.PROBABILISTIC/*pselect*/, stableE, stableK, false, logger);

        Node[] goalNodes = new Node[1];
        goalNodes[0] = new GoalNode(0,"G", logger);
        goalNodes[0].addChild(planNodes[0]);
        goalNodes[0].addChild(planNodes[1]);
        goalNodes[0].addChild(planNodes[2]);
        goalNodes[0].addChild(planNodes[3]);
        goalNodes[0].addChild(planNodes[4]);

        planNodes[1].addChild(goalNodes[0]);
        planNodes[1].addChild(goalNodes[0]);
        planNodes[2].addChild(goalNodes[0]);
        planNodes[2].addChild(goalNodes[0]);

    }
    
    // Application entry point.
    public static void main(String[] args) {

        // Default Config
        int numDiscs = 9;
        boolean visible = false;
        boolean learningMode = false;
        PlanSelectMode pselect = PlanSelectMode.PROBABILISTIC;
        UpdateMode uselect = UpdateMode.CONCURRENT;
        int minInstances = 1;
        int stableK = 1;
        double stableE = 0.5;
        int episodes=1;
        int recursion = 20;
        String targetDir = ".";
        String filename = "player.csv";
        long seed = 0;
        boolean saveInit = false;
        
        args = Jak.initialize(args);
        if (args.length > 0) {
            int index = 0;
            while (index < args.length) {
                String arg = args[index];
                index++;
                char option = arg.charAt(1);
                switch (option) {
                case 'd':
                    targetDir = args[index];
                    index++;
                    break;
                case 'e':
                    stableE = Double.parseDouble(args[index]);
                    index++;
                    break;
                case 'g':
                    seed = Long.parseLong(args[index]);
                    index++;
                    break;
                case 'h':
                    System.out.println("Valid options are:");
                    System.out.println(" -h: Help message");
                    System.out.println(" -w: Show GUI while solving");
                    System.out.println(" -x: Learning mode. Disables relevance and context checks");
                    System.exit(0);
                case 'i':
                    episodes = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'j':
                    numDiscs = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'k':
                    stableK = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'm':
                    minInstances = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'o':
                    filename = args[index];
                    index++;
                    break;
                case 'r':
                    recursion = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 's':
                    String psmode = args[index];
                    index++;
                    if (psmode.equals("probabilistic"))
                        pselect = PlanSelectMode.PROBABILISTIC;
                    if (psmode.equals("coverage"))
                        pselect = PlanSelectMode.COVERAGE;
                    break;
                case 'u':
                    String umode = args[index];
                    index++;
                    if (umode.equals("stable"))
                        uselect = UpdateMode.STABLE;
                    if (umode.equals("concurrent"))
                        uselect = UpdateMode.CONCURRENT;
                break;
                case 'w':
                    visible = true;
                    break;
                case 'x':
                    learningMode = true;
                    break;
                case 'z':
                    saveInit = true;
                    break;
                }
            }
        }
        System.out.println("Using random generator seed: "+seed);
        Player p = new Player(numDiscs, visible, learningMode, episodes, recursion, pselect, uselect, minInstances, stableK, stableE, targetDir, filename, seed, saveInit);
        p.go();
    }
}

class HanoiState implements Serializable{
    /* Stores key="d,p,r" where
     * d: disk to move,
     * p: pin to move to, and
     * r: recursion depth of the solution
     * The value is an Integer[] of size numDiscs,
     * where each elementAt(i) is the disc number below disk i.
     */
    private int numDiscs;
    private Hashtable state;

    public HanoiState(int discs) {
        numDiscs = discs;
        state = new Hashtable();
    }
    
    public void set(String key, Integer[] val) {
        state.put(key,val);
    }
    
    public Vector get(String key) {
        return (state.containsKey(key)) ? (Vector)(state.get(key)) : new Vector();
    }

    public int id() {
        return numDiscs;
    }
    
    public int size() {
        return state.size();
    }
}
