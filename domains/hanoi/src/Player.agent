/*************************************************************
 * This file is generated by the JACK Development Environment.
 * Saved at: Thu Feb 21 17:28:43 EST 2002
 * WARNING: DO NOT EDIT THIS OR YOUR CHANGES MAY BE LOST
 *************************************************************/

import aos.util.Properties;
import aos.jack.jak.beliefset.BeliefSetException;

import java.util.*;
import java.io.*;

import trees.Logger;
import trees.Tree;
import trees.Node;

import agents.PlanNode;
import agents.GoalNode;
import agents.Config.PlanSelectMode;
import agents.Config.UpdateMode;
import agents.Config.RunMode;

import weka.core.FastVector;
import weka.core.Attribute;

import gui.Towers;

/* Documentation */

/**
   The Player agent solves the Towers of Hanoi puzzle.
   It has three capabilities:
   - DiscStacking, which includes initialising the puzzle and then
         provide the solution strategy;
   - Solving, which includes plans for solving the puzzle, i.e. which
         move to do next;
   - DiscMoving, which deals with actually moving discs.
**/

public agent Player extends Agent implements Logger{
    #private data Order order();
    #private data Top top();
    #private data Place place();
    #private data Towers window("Towers of Hanoi");
    #has capability DiscStacking stacking;
    #has capability Solving solving;
    #has capability DiscMoving moving;
    #posts event StackingStart ss;
	#uses plan MetaPlan;
	#handles event PlanChoice;
    
    private int numDiscs;
    private int numPins;

    private boolean learningMode;
    private boolean demoMode  = false;
    
    private int episode = 0;
    private int maxEpisodes = 0;
    private int maxRecursion = 0;
    
    private PlanSelectMode pselect;
    
    private String targetDir;
    private String filename;
    
    private Random generator;
    private Random selector;
    private PrintWriter writerOut;
    private PrintWriter writerRes;
    
    private HanoiState init;
    private String episodeGoalKey;
    private Integer[] episodeStartState;
    private int maxDepthThisEpisode;

    private boolean saveInitStates;
    private String saveInitToFile;
    private boolean loadInitStates;
    private String loadInitFromFile;
    private int generateSolutionsAtLevel;
    
    private double applicabilityThreshold;
    
    private int indent = 0;
    
	Tree gpTree;
    public PlanNode[] planNodes;
    private PlanNode failureNode;
    private int failureNodeDepth;

    // Constructor
    Player(int nDiscs, boolean visible, boolean learning, int episodes, int recursion, PlanSelectMode pselect, UpdateMode uselect, int minInstances, int stableK, double stableE, String targetDir, String filename, long seed, String loadInit, int solutionLevel, String saveInit, double domainDecay, double threshold) {
        super("player");
        
        this.init = new HanoiState(nDiscs);
        this.episodeStartState = null;
        this.episodeGoalKey = "";
        this.maxDepthThisEpisode = 0;
        
        this.numDiscs = nDiscs;
        this.numPins = 3;
        
        this.pselect = pselect;
        this.maxRecursion = recursion;
        generator = (seed == 0) ? new Random() : new Random(seed);
        selector = new Random();
        
        this.targetDir = targetDir;
        this.filename = filename;
        
        this.applicabilityThreshold = threshold;
        
        try{
            writerOut = new PrintWriter(targetDir + "/player.out");
            writerRes = new PrintWriter(targetDir + "/" + filename + "-episodes.csv");
        }catch(IOException e){
            System.err.println("Error opening the file for writing the outcome \n"+e);
            System.exit(9);
        }

        this.generateSolutionsAtLevel = solutionLevel;
        this.saveInitStates = (saveInit != null) ? true : false;
        this.saveInitToFile = saveInit;
        this.loadInitStates = (loadInit != null) ? true : false;
        this.loadInitFromFile = loadInit;
        if (loadInitStates) {
            try {
                String fname = targetDir + "/" + loadInitFromFile;
                ObjectInputStream readerObj = new ObjectInputStream(new FileInputStream(fname));


                Object obj = readerObj.readObject();
                if (obj != null && obj instanceof HanoiState) {
                    init = (HanoiState)obj;
                    if (init.id() != nDiscs) {
                        System.err.println("Hanoi states in file " + fname + " are for "+init.id()+" discs. Should be same as numDiscs i.e "+nDiscs);
                        System.exit(9);
                    }
                    writeLog("Loaded initial hanoi states from file " + fname);
                    writeLog(init.toString());
                }
                readerObj.close();
            } catch (Exception e) {
                System.err.println("Error loading initial states: "+e);
            }
        }
                
        episode = 0;
        maxEpisodes = episodes;
        learningMode = learning;
        failureNode = null;
        failureNodeDepth = 0;
        if (learningMode) {
            initLearning((trees.Logger)this, numDiscs, numPins, recursion, pselect, uselect, minInstances, stableK, stableE, domainDecay, threshold);
        }

        episodeGoalKey = loadNewState();
        
        if (visible) {
            window.initFrame();
        }
    }

    public void setMaxDepthThisEpisode(int depth) {
        maxDepthThisEpisode = depth;
    }

    public int maxDepthThisEpisode() {
        return maxDepthThisEpisode;
    }

    public int maxRecursion() {
        return maxRecursion;
    }

    public int maxEpisodes() {
        return maxEpisodes;
    }

    public int numDiscs() {
        return numDiscs;
    }

    public int numPins() {
        return numPins;
    }

    public int episode() {
        return episode;
    }

    public boolean learningMode() {
        return learningMode;
    }

    public boolean demoMode() {
        return demoMode;
    }

    public Random generator() {
        return generator;
    }

    public Random selector() {
        return selector;
    }

    public PlanSelectMode pselect() {
        return pselect;
    }

    public String getGoalKeyThisEpisode() {
        return episodeGoalKey;
    }

    public void setGoalKeyThisEpisode(String key) {
        episodeGoalKey = key;
    }
    
    public boolean initSupplied() {
        return loadInitStates;
    }
    
    public double applicabilityThreshold() {
        return applicabilityThreshold;
    }
    
    public void record(int pid, boolean res, String[] state, int depth) {
        boolean isRoot = (depth == maxRecursion);
        /** Only the first caller for the episode will succeed */
        if (!res && failureNode == null) {
            failureNode = planNodes[pid];
            failureNodeDepth = depth;
            writeLog("Episode "+episode+" first failure node was "+failureNode.name()+" at depth "+failureNodeDepth+" with complexity="+failureNode.getComplexity(failureNodeDepth));
        }
        planNodes[pid].setLastInstance(state);
        planNodes[pid].record(res, true/*isStableBelow: don't care*/, depth, isRoot, (!res) ? failureNode.getComplexity(failureNodeDepth) : 1.0);
    }

    public void finishEpisode() {
        indentReset();
        if (saveInitStates) {
            saveInitState();
        }
        episodeGoalKey = loadNewState();
        failureNode = null;
        episode++;
        maxDepthThisEpisode = 0;
    }
    
    public void saveInitState() {
        String depthKey = Integer.toString(maxDepthThisEpisode);
        init.set(depthKey, episodeGoalKey, episodeStartState);
        String ess = "";
        for (int i = 0; i < episodeStartState.length; i++) {
            ess += episodeStartState[i].toString();
        }
        writeLog("Stored state depthKey["+depthKey+"], goalKey["+episodeGoalKey+"], val["+ess+"]");
    }
    
    public String loadNewState() {
        String depthKey = Integer.toString(generateSolutionsAtLevel);
        if (generateSolutionsAtLevel == -1) {
            depthKey = Integer.toString(selector.nextInt(init.size()));
        }
        String goalKey = init.getRandomSecondKey(generator,depthKey);

        if (loadInitStates && (goalKey != null)) {
            try {
                order.deleteAll();
                Integer[] discBelow = init.get(generator, depthKey, goalKey);
                String ess = "";
                for (int i = 0; i < discBelow.length; i++) {
                    ess += discBelow[i].toString();
                }
                writeLog("Retrieved state depthKey["+depthKey+"], goalKey["+goalKey+"], val["+ess+"]");
                for (int i = 0; i < discBelow.length; i++) {
                    order.add(i+1,discBelow[i].intValue());
                }
            } catch (Exception e) {
                System.err.println("Error initialising loaded order of discs\n"+e);
                System.exit(9);
            }
            writeLog("Loaded initial hanoi state for depthKey["+depthKey+"] and goalKey["+goalKey+"]");
        } else {
            newRandomOrder();
            writeLog("Generated random initial hanoi state");
        }

        try {
            episodeStartState = new Integer[numDiscs];
            for (int i = 0; i < numDiscs; i++) {
                episodeStartState[i]=new Integer(order.getBelow(i+1));
            }
        } catch (Exception e) {
            System.err.println("Error initialising start state order\n"+e);
            System.exit(9);
        }
        return goalKey;
    }
    
    public void newRandomOrder() {
        try {
            order.deleteAll();
            int[] tops = new int[3];
            tops[0] = 0;
            tops[1] = 0;
            tops[2] = 0;
            for (int i = 1; i <= numDiscs; i++) {
                int r = generator.nextInt(3);
                order.add(i,tops[r]);
                tops[r] = i;
            }
        } catch (Exception e) {
            System.err.println("Error initialising the order of discs on the pins\n"+e);
            System.exit(9);
        }
    }
    
    Integer[] tops() {
        Integer[] t = new Integer[numPins];
        for (int i = 0; i < t.length; i++) {
            try{
                t[i] = new Integer(top.get(i));
            } catch (BeliefSetException e) {
                System.err.println("Error accessing belief top.get("+i+")\n"+e);
                System.exit(9);
            }
        }
        return t;
    }

    Integer[] places() {
        Integer[] p = new Integer[numDiscs];
        for (int i = 1; i <= p.length; i++) {
            try{
                p[i-1] = new Integer(place.get(i));
            } catch (BeliefSetException e) {
                System.err.println("Error accessing belief place.get("+i+")\n"+e);
                System.exit(9);
            }
        }
        return p;
    }

    Integer[] discsOnTop() {
        Integer[] n = new Integer[numDiscs];
        for (int i = 1; i <= n.length; i++) {
            try{
                int top = i;
                int count = -1;
                do {
                    top = order.get(top);
                    count++;
                } while (top != -1);
                n[i-1] = new Integer((count>0)?1:0);
            } catch (BeliefSetException e) {
                System.err.println("Error accessing belief place.get("+i+")\n"+e);
                System.exit(9);
            }
        }
        return n;
    }

    public PlanIdInfo planInfo(int pid, String[] state, int level, int rec) {
        if (learningMode) {
            PlanNode thisNode = planNodes[pid];
            double confidence = thisNode.getConfidence(level,state);
            double[] ps = thisNode.getProbability(state);
            return new PlanIdInfo(pid, ps[0], confidence, thisNode.isFailedThresholdHandler());
        } else {
            return new PlanIdInfo(pid, 0.5, 1.0, false);
        }
    }

    public void go() {
        postEvent(ss.start(true));
    }

    public void finish() {
        if (learningMode) {
            for (int i = 0; i < planNodes.length; i++) {
                writeLog(planNodes[i].getDT());
            }
        }
        if (saveInitStates) {
            try {
                String filename = targetDir + "/" + saveInitToFile;
                ObjectOutputStream writerObj = new ObjectOutputStream(new FileOutputStream(filename));
                writerObj.writeObject(init);
                writerObj.close();
                writeLog("Saved initial hanoi states to file " + filename);
                writeLog(init.toString());
            } catch (Exception e) {
                System.err.println("Error saving initial states: "+e);
            }
        }
        writerOut.close();
        writerRes.close();
    }
    
    public void indentRight() {
        indent++;
    }

    public void indentLeft() {
        indent--;
    }
    
    public void indentReset() {
        indent=0;
    }

    public void writeLog(String str) {
        String s = "";
        for (int i = 0;(i < indent);i++ ) s+= " ";
        writerOut.println(s + str);
        writerOut.flush();
    }
    public void writeResult(int episode, boolean result) {
        String str = episode + (result ? " 1.0 0.0" : " 0.0 1.0");
        writerRes.println(str);
        writerRes.flush();
    }
    
    public void initLearning(Logger logger, int nDiscs, int nPins, int recursion, PlanSelectMode pselect, UpdateMode uselect, int minInstances, int stableK, double stableE, double domainDecay, double threshold) {
        FastVector classVal = new FastVector();
        classVal.addElement("+");
        classVal.addElement("-");

        FastVector bval = new FastVector();
        bval.addElement("T");
        bval.addElement("F");

        FastVector dval = new FastVector();
        for (int i = 0; i < nDiscs+1; i++) {
            dval.addElement(Integer.toString(i));
        }

        FastVector pval = new FastVector();
        for (int i = 0; i < 3; i++) {
            pval.addElement(Integer.toString(i));
        }

        FastVector rval = new FastVector();
        for (int i = 0; i <= recursion; i++) {
            rval.addElement(Integer.toString(i));
        }
        
        FastVector atts = new FastVector();
        atts.addElement(new Attribute("disc"));
        atts.addElement(new Attribute("pin",pval));
        atts.addElement(new Attribute("recursionLevel"));
        
        //for (int i = 0; i < nPins; i++) {
        //    atts.addElement(new Attribute("topDiscOnPin"+i));
        //}
        for (int i = 1; i <= nDiscs; i++) {
            atts.addElement(new Attribute("discsOnTopOf"+i));
        }
        for (int i = 1; i <= nDiscs; i++) {
            atts.addElement(new Attribute("pinOfDisc"+i,pval));
        }

        atts.addElement(new Attribute("outcome",classVal));
    

        planNodes = new PlanNode[6];
        planNodes[0] = new PlanNode("P0", atts, uselect, pselect, RunMode.DEFAULT, stableE, stableK, false, logger);
        planNodes[1] = new PlanNode("P1", atts, uselect, pselect, RunMode.DEFAULT, stableE, stableK, false, logger);
        planNodes[2] = new PlanNode("P2", atts, uselect, pselect, RunMode.DEFAULT, stableE, stableK, false, logger);
        planNodes[3] = new PlanNode("P3", atts, uselect, pselect, RunMode.DEFAULT, stableE, stableK, false, logger);
        planNodes[4] = new PlanNode("P4", atts, uselect, pselect, RunMode.DEFAULT, stableE, stableK, false, logger);
        planNodes[5] = new PlanNode("PF", atts, uselect, pselect, RunMode.DEFAULT, stableE, stableK, true, logger);

        planNodes[0].setDecayMultiplier(domainDecay);
        planNodes[1].setDecayMultiplier(domainDecay);
        planNodes[2].setDecayMultiplier(domainDecay);
        planNodes[3].setDecayMultiplier(domainDecay);
        planNodes[4].setDecayMultiplier(domainDecay);

        Node[] goalNodes = new Node[1];
        goalNodes[0] = new GoalNode("G", logger);
        goalNodes[0].addChild(planNodes[0]);
        goalNodes[0].addChild(planNodes[1]);
        goalNodes[0].addChild(planNodes[2]);
        goalNodes[0].addChild(planNodes[3]);
        goalNodes[0].addChild(planNodes[4]);
        goalNodes[0].addChild(planNodes[5]);

        planNodes[0].addChild(goalNodes[0]);
        planNodes[0].addChild(goalNodes[0]);
        planNodes[2].addChild(goalNodes[0]);
        planNodes[2].addChild(goalNodes[0]);

        /* Complexity calculation
         * For recursive nodes:
         * c = [ log2(d+2) ] ^ (p^g) where
         * c: complexity
         * d: depth in the goal plan hierarchy (leaf is d=0)
         * p: maximum branching for plans in the gp-hierarchy
         * g: maximum branching for goals in the gp-hierarchy
         * For non-recursive nodes we use the above formaula with d=1
         */
        int p = 4;
        int g = 2;
        for (int d = 0; d <= recursion; d++) {
            double ln = Math.log(d+2.0)/Math.log(2.0);
            double pg = Math.pow(p,g);
            double c = Math.pow(ln, pg);
            planNodes[0].setComplexity(d, c);
            planNodes[1].setComplexity(d, pg);
            planNodes[2].setComplexity(d, c);
            planNodes[3].setComplexity(d, pg);
            planNodes[4].setComplexity(d, pg);
        }
    }
    
    // Application entry point.
    public static void main(String[] args) {

        // Default Config
        int numDiscs = 9;
        boolean visible = false;
        boolean learningMode = false;
        PlanSelectMode pselect = PlanSelectMode.PROBABILISTIC;
        UpdateMode uselect = UpdateMode.CONCURRENT;
        int minInstances = 1;
        int stableK = 1;
        double stableE = 0.5;
        int episodes=1;
        int recursion = 20;
        String targetDir = ".";
        String filename = "player.csv";
        long seed = 0;
        String saveInit = null;
        String loadInit = null;
        int generateSolutionsAtLevel = 0;
        double domainDecayMultiplier = 0.0; 
        double threshold = 0.0;
        
        args = Jak.initialize(args);
        if (args.length > 0) {
            int index = 0;
            while (index < args.length) {
                String arg = args[index];
                index++;
                char option = arg.charAt(1);
                switch (option) {
                case 'c':
                    domainDecayMultiplier = Double.parseDouble(args[index]);
                    index++;
                    break;
                case 'd':
                    targetDir = args[index];
                    index++;
                    break;
                case 'e':
                    stableE = Double.parseDouble(args[index]);
                    index++;
                    break;
                case 'g':
                    seed = Long.parseLong(args[index]);
                    index++;
                    break;
                case 'h':
                    System.out.println("Valid options are:");
                    System.out.println(" -h: Help message");
                    System.out.println(" -w: Show GUI while solving");
                    System.out.println(" -x: Learning mode. Disables relevance and context checks");
                    System.exit(0);
                case 'i':
                    episodes = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'j':
                    numDiscs = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'k':
                    stableK = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'm':
                    minInstances = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'o':
                    filename = args[index];
                    index++;
                    break;
                case 'p':
                    generateSolutionsAtLevel = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'r':
                    recursion = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 's':
                    String psmode = args[index];
                    index++;
                    if (psmode.equals("probabilistic"))
                        pselect = PlanSelectMode.PROBABILISTIC;
                    if (psmode.equals("coverage"))
                        pselect = PlanSelectMode.COVERAGE;
                    if (psmode.equals("confidence"))
                        pselect = PlanSelectMode.CONFIDENCE;
                    break;
                case 't':
                    threshold = Double.parseDouble(args[index]);
                    index++;
                    break;
                case 'u':
                    String umode = args[index];
                    index++;
                    if (umode.equals("stable"))
                        uselect = UpdateMode.STABLE;
                    if (umode.equals("concurrent"))
                        uselect = UpdateMode.CONCURRENT;
                break;
                case 'w':
                    visible = true;
                    break;
                case 'x':
                    learningMode = true;
                    break;
                case 'y':
                    loadInit = args[index];
                    index++;
                    break;
                case 'z':
                    saveInit = args[index];
                    index++;
                    break;
                }
            }
        }
        System.out.println("Using random generator seed: "+seed);
        Player p = new Player(numDiscs, visible, learningMode, episodes, recursion, pselect, uselect, minInstances, stableK, stableE, targetDir, filename, seed, loadInit, generateSolutionsAtLevel, saveInit, domainDecayMultiplier, threshold);
        p.go();
    }
}

class HanoiState implements Serializable{
    /* Stores key="d,p,r" where
     * d: disk to move,
     * p: pin to move to, and
     * r: recursion depth of the solution
     * The value is an Integer[] of size numDiscs,
     * where each elementAt(i) is the disc number below disk i.
     */
    private int numDiscs;
    private Hashtable state;

    public HanoiState(int discs) {
        numDiscs = discs;
        state = new Hashtable();
    }
    
    public void set(String key1, String key2, Integer[] val) {
        Hashtable hash2 = (state.containsKey(key1)) ? (Hashtable)(state.get(key1)) : new Hashtable();
        Vector vals = (hash2.containsKey(key2)) ? (Vector)(hash2.get(key2)) : new Vector();
        vals.add(val);
        hash2.put(key2,vals);
        state.put(key1,hash2);
    }

    public String getRandomSecondKey(Random gen, String key1) {
        if (!state.containsKey(key1)) {
            return null;
        }
        String str = "";
        Hashtable hash2 =  (Hashtable)(state.get(key1));
        int pick = gen.nextInt(hash2.size());
        int count = 0;
        for (Enumeration e = hash2.keys(); e.hasMoreElements();) {
            str = (String)(e.nextElement());
            if (count == pick) {
                break;
            }
            count++;
        }
        return str;
    }
    
    public Integer[] get(Random gen, String key1, String key2) {
        Hashtable hash2 = (state.containsKey(key1)) ? (Hashtable)(state.get(key1)) : new Hashtable();
        Vector vals = (hash2.containsKey(key2)) ? (Vector)(hash2.get(key2)) : new Vector();
        int pick = gen.nextInt(vals.size());
        return (vals.size() > 0) ? (Integer[])(vals.elementAt(pick)) : new Integer[0];
    }

    public int id() {
        return numDiscs;
    }
    
    public int size() {
        return state.size();
    }
    
    public String toString() {
        String stats = "";
        String key1 = "";
        String key2 = "";
        for (Enumeration e = state.keys(); e.hasMoreElements();) {
            key1 = (String)(e.nextElement());
            Hashtable hash2 = (Hashtable)(state.get(key1));
            int key2sz = 0;
            int sz = 0;
            for (Enumeration ee = hash2.keys(); ee.hasMoreElements();) {
                key2 = (String)(ee.nextElement());
                Vector vals = (Vector)(hash2.get(key2));
                sz += vals.size();
                key2sz ++;
            }
            Object[] a = new Object[3];
            a[0] = key1;
            a[1] = new Integer(key2sz);
            a[2] = new Integer(sz);
            stats += String.format("key:%-5s keys:%-5d size:%d\n", a);
        }
        return stats;
    }
}
