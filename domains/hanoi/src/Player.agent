/*************************************************************
 * This file is generated by the JACK Development Environment.
 * Saved at: Thu Feb 21 17:28:43 EST 2002
 * WARNING: DO NOT EDIT THIS OR YOUR CHANGES MAY BE LOST
 *************************************************************/

import aos.util.Properties;
import gui.Towers;
import java.util.Random;
import java.io.PrintWriter;
import java.io.IOException;

/* Documentation */

/**
   The Player agent solves the Towers of Hanoi puzzle.
   It has three capabilities:
   - DiscStacking, which includes initialising the puzzle and then
         provide the solution strategy;
   - Solving, which includes plans for solving the puzzle, i.e. which
         move to do next;
   - DiscMoving, which deals with actually moving discs.
**/

public agent Player extends Agent {
    #private data Order order(initfile);
    #private data Top top();
    #private data Place place();
    #private data Towers window("Towers of Hanoi");
    #has capability DiscStacking stacking;
    #has capability Solving solving;
    #has capability DiscMoving moving;
    #posts event StackingStart ss;
	#uses plan MetaPlan;
	#handles event PlanChoice;
    
    public static int PROBABILISTIC_PS = 1;
    public static int COVERAGE_PS = 2;

    public boolean isVisible;
    public boolean learningMode;
    public int pselect;
    public Random generator;
    public PrintWriter writer;
    
    private int indent = 0;

    // Constructor
    Player() {
        super("player");
        isVisible = false;
        learningMode = false;
        generator = new Random();
        try{
            writer = new PrintWriter("./player.out");
        }catch(IOException e){
            System.err.println("error opening the file for writing the outcome \n"+e);
            System.exit(9);
        }
    }
    
    public void setVisible(boolean show) {
        isVisible = show;
        window.setVisible(isVisible);
    }

    public void go() {
        postEvent(ss.start());
    }

    // This names the initialisation file for the Order relation.
    static String initfile = "init.dat";

    public void record(int pid, boolean res, int disc, int pin) {
    
        // Record the result in the decision tree
        String rstr = (res) ? "(+)" : "(-)";
        this.log("Recording "+rstr+" in plan "+pid+" for move disc "+disc+" to pin "+pin);        
    }

    public void finish() {
        writer.close();
    }
    
    public void logIndentRight() {
        indent++;
    }

    public void logIndentLeft() {
        indent--;
    }
    
    public void logIndentReset() {
        indent=0;
    }

    public void log(String str) {
        String s = "";
        for (int i = 0;(i < indent);i++ ) s+= " ";
        writer.println(s + str);
        writer.flush();
    }
    
    
    // Application entry point.
    public static void main(String[] args) {
        boolean visible = false;
        boolean learningMode = false;
        int pselect = 1;
        args = Jak.initialize(args);
        if (args.length > 0) {
            int index = 0;
            while (index < args.length) {
                String arg = args[index];
                index++;
                char option = arg.charAt(1);
                switch (option) {
                case 'h':
                    System.out.println("Valid options are:");
                    System.out.println(" -h: Help message");
                    System.out.println(" -w: Show GUI while solving");
                    System.out.println(" -x: Learning mode. Disables relevance and context checks");
                    System.exit(0);
                case 'w':
                    visible = true;
                    break;
                case 'x':
                    learningMode = true;
                    break;
                case 's':
                    String psmode = args[index];
                    index++;
                    if (psmode.equals("probabilistic"))
                        pselect = PROBABILISTIC_PS;
                    if (psmode.equals("coverage"))
                        pselect = COVERAGE_PS;
                break;
                }
            }
        }
        Player p = new Player();
        p.setVisible(visible);
        p.learningMode = learningMode;
        p.pselect = pselect;
        p.go();
    }
}

