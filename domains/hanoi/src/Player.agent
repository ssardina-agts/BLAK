/*************************************************************
 * This file is generated by the JACK Development Environment.
 * Saved at: Thu Feb 21 17:28:43 EST 2002
 * WARNING: DO NOT EDIT THIS OR YOUR CHANGES MAY BE LOST
 *************************************************************/

import aos.util.Properties;
import aos.jack.jak.beliefset.BeliefSetException;
import gui.Towers;
import java.util.Random;
import java.io.PrintWriter;
import java.io.IOException;

import trees.Logger;
import trees.Tree;
import trees.Node;
import agents.PlanNode;
import agents.GoalNode;
import agents.Config.PlanSelectMode;
import agents.Config.UpdateMode;

import weka.core.FastVector;
import weka.core.Attribute;

/* Documentation */

/**
   The Player agent solves the Towers of Hanoi puzzle.
   It has three capabilities:
   - DiscStacking, which includes initialising the puzzle and then
         provide the solution strategy;
   - Solving, which includes plans for solving the puzzle, i.e. which
         move to do next;
   - DiscMoving, which deals with actually moving discs.
**/

public agent Player extends Agent implements Logger{
    #private data Order order();
    #private data Top top();
    #private data Place place();
    #private data Towers window("Towers of Hanoi");
    #has capability DiscStacking stacking;
    #has capability Solving solving;
    #has capability DiscMoving moving;
    #posts event StackingStart ss;
	#uses plan MetaPlan;
	#handles event PlanChoice;
    
    public boolean learningMode;
    
    public int episode = 0;
    public int maxEpisodes = 0;
    public int maxRecursion = 0;
    
    public PlanSelectMode pselect;
    
    public String targetDir;
    public String filename;
    
    public Random generator;
    public PrintWriter writerOut;
    public PrintWriter writerRes;
    
    private int indent = 0;
    
	Tree gpTree;
    public PlanNode[] planNodes;

    public boolean alreadyOnTargetPin = false;
    public boolean isSourcePinBlocked = false;
    public boolean isTargetPinBlocked = false;

    // Constructor
    Player(boolean visible, boolean learning, int episodes, int recursion, PlanSelectMode pselect, UpdateMode uselect, int minInstances, int stableK, double stableE, String targetDir, String filename) {
        super("player");
        this.pselect = pselect;
        this.maxRecursion = recursion;
        generator = new Random();
        
        this.targetDir = targetDir;
        this.filename = filename;
        
        try{
            writerOut = new PrintWriter(targetDir + "/player.out");
            if (learning) {
                writerRes = new PrintWriter(targetDir + "/" + filename);
            }
        }catch(IOException e){
            System.err.println("Error opening the file for writing the outcome \n"+e);
            System.exit(9);
        }
        
        learningMode = learning;
        if (learningMode) {
            episode = 0;
            maxEpisodes = episodes;
            initLearning((trees.Logger)this, pselect, uselect, minInstances, stableK, stableE);
        }
        
        // Initial order
        try {
            order.add(7,4);
            order.add(4,1);
            order.add(1,0);
            order.add(8,5);
            order.add(5,2);
            order.add(2,0);
            order.add(9,6);
            order.add(6,3);
            order.add(3,0);
        } catch (BeliefSetException e) {
            System.err.println("Error initialising the order of discs on the pins\n"+e);
            System.exit(9);
        }
    
        if (visible) {
            window.initFrame();
        }
    }
    
    public void go() {
        postEvent(ss.start(true));
    }

    public String[] learningState(){
        // Construct the state string
        String[] state = new String[3];
        state[0]=Boolean.toString(alreadyOnTargetPin);
        state[1]=Boolean.toString(isSourcePinBlocked);
        state[2]=Boolean.toString(isTargetPinBlocked);
        return state;
    }

    public void finish() {
        writerOut.close();
        if (learningMode) {
            writerRes.close();
        }
    }
    
    public void indentRight() {
        indent++;
    }

    public void indentLeft() {
        indent--;
    }
    
    public void indentReset() {
        indent=0;
    }

    public void writeLog(String str) {
        String s = "";
        for (int i = 0;(i < indent);i++ ) s+= " ";
        writerOut.println(s + str);
        writerOut.flush();
    }
    public void writeResult(int episode, boolean result) {
        if (learningMode) {
            String str = episode + (result ? " 1.0 0.0" : " 0.0 1.0");
            writerRes.println(str);
            writerRes.flush();
        }
    }
    
    public void initLearning(Logger logger, PlanSelectMode pselect, UpdateMode uselect, int minInstances, int stableK, double stableE) {
        FastVector classVal = new FastVector();
        classVal.addElement("+");
        classVal.addElement("-");

        FastVector boolVal = new FastVector();
        boolVal.addElement("T");
        boolVal.addElement("F");

        /*
        FastVector discVal = new FastVector();
        discVal.addElement("0");
        discVal.addElement("1");
        discVal.addElement("2");
        discVal.addElement("3");
        discVal.addElement("4");
        discVal.addElement("5");
        discVal.addElement("6");
        discVal.addElement("7");
        discVal.addElement("8");
        discVal.addElement("9");

        FastVector pinVal = new FastVector();
        pinVal.addElement("0");
        pinVal.addElement("1");
        pinVal.addElement("2");
        */
        
        FastVector atts = new FastVector();
        //atts.addElement(new Attribute("disc",discVal));
        //atts.addElement(new Attribute("pin",pinVal));
        atts.addElement(new Attribute("alreadyOnTargetPin",boolVal));
        atts.addElement(new Attribute("isSourcePinBlocked",boolVal));
        atts.addElement(new Attribute("isTargetPinBlocked",boolVal));
        atts.addElement(new Attribute("outcome",classVal));
    

        planNodes = new PlanNode[5];
        planNodes[0] = new PlanNode(new Integer(0),"P0", atts, classVal, boolVal, minInstances, uselect, stableE, stableK, false, logger);
        planNodes[1] = new PlanNode(new Integer(1),"P1", atts, classVal, boolVal, minInstances, uselect, stableE, stableK, false, logger);
        planNodes[2] = new PlanNode(new Integer(2),"P2", atts, classVal, boolVal, minInstances, uselect, stableE, stableK, false, logger);
        planNodes[3] = new PlanNode(new Integer(3),"P3", atts, classVal, boolVal, minInstances, uselect, stableE, stableK, false, logger);
        planNodes[4] = new PlanNode(new Integer(4),"P4", atts, classVal, boolVal, minInstances, uselect, stableE, stableK, false, logger);

        Node[] goalNodes = new Node[1];
        goalNodes[0] = new GoalNode(0,"SolveDisc", logger);
        goalNodes[0].addChild(planNodes[0]);
        goalNodes[0].addChild(planNodes[1]);
        goalNodes[0].addChild(planNodes[2]);
        goalNodes[0].addChild(planNodes[3]);
        goalNodes[0].addChild(planNodes[4]);

        planNodes[0].setTopGoal((GoalNode)goalNodes[0]);
        planNodes[1].setTopGoal((GoalNode)goalNodes[0]);
        planNodes[2].setTopGoal((GoalNode)goalNodes[0]);
        planNodes[3].setTopGoal((GoalNode)goalNodes[0]);
        planNodes[4].setTopGoal((GoalNode)goalNodes[0]);
    }
    
    // Application entry point.
    public static void main(String[] args) {

        // Default Config
        boolean visible = false;
        boolean learningMode = false;
        PlanSelectMode pselect = PlanSelectMode.PROBABILISTIC;
        UpdateMode uselect = UpdateMode.CONCURRENT;
        int minInstances = 1;
        int stableK = 1;
        double stableE = 0.5;
        int episodes=1;
        int recursion = 20;
        String targetDir = ".";
        String filename = "player.csv";
        
        args = Jak.initialize(args);
        if (args.length > 0) {
            int index = 0;
            while (index < args.length) {
                String arg = args[index];
                index++;
                char option = arg.charAt(1);
                switch (option) {
                case 'h':
                    System.out.println("Valid options are:");
                    System.out.println(" -h: Help message");
                    System.out.println(" -w: Show GUI while solving");
                    System.out.println(" -x: Learning mode. Disables relevance and context checks");
                    System.exit(0);
                case 'w':
                    visible = true;
                    break;
                case 'x':
                    learningMode = true;
                    break;
                case 's':
                    String psmode = args[index];
                    index++;
                    if (psmode.equals("probabilistic"))
                        pselect = PlanSelectMode.PROBABILISTIC;
                    if (psmode.equals("coverage"))
                        pselect = PlanSelectMode.COVERAGE;
                    break;
                case 'u':
                    String umode = args[index];
                    index++;
                    if (umode.equals("stable"))
                        uselect = UpdateMode.STABLE;
                    if (umode.equals("concurrent"))
                        uselect = UpdateMode.CONCURRENT;
                break;
                case 'm':
                    minInstances = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'k':
                    stableK = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'e':
                    stableE = Double.parseDouble(args[index]);
                    index++;
                    break;
                case 'i':
                    episodes = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'r':
                    recursion = Integer.parseInt(args[index]);
                    index++;
                    break;
                case 'd':
                    targetDir = args[index];
                    index++;
                    break;
                case 'o':
                    filename = args[index];
                    index++;
                    break;
                }
            }
        }
        Player p = new Player(visible, learningMode, episodes, recursion, pselect, uselect, minInstances, stableK, stableE, targetDir, filename);
        p.go();
    }
}

