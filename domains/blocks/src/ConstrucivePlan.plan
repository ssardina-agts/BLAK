import agents.PlanNode;
import PlanIdInfo;

plan ConstructivePlan extends Plan
{
	#handles event MoveEvent ev;
	#posts event MoveEvent me;
	#posts event PrintEvent pe;
	#posts event UpdateEvent ue;

	#uses interface BWAgent ag;
	
	#modifies data Order order;
	#modifies data Movable mv;
	#modifies data GoalNew gl;
	#reads data Blocks bl;

    public int pid = 0;

	public logical String first; 
	public logical String second;
	logical int a;
	logical int b;	
	public int thisState;

    public PlanInstanceInfo getInstanceInfo(){
        return ag.planInfo(pid,thisState);
    }

	boolean 
	relevant(MoveEvent m)
	{	
		return true;

	}
	
	context()
	{
		mv.get(a,first) && mv.get(b,second) &&          // find two free blocks
        gl.get(first.getValue(),second.getValue()) &&   // and where the goal is to have the first on the second
        ag.isGoalTower(second.getValue()) &&            // and where the second is a goal tower
		assign1() &&									// make the state to be 1
		!first.getValue().equals(second.getValue()) &&  // that are unique
		!first.getValue().equals("table") &&            // and not references to
        !second.getValue().equals("table") &&
        ((!first.getValue().equals(second.getValue()) && // check the action condition
        !first.getValue().equals("table") &&            //  true assign the state to 2
        !second.getValue().equals("table"))             
		? assign2() : true);		
	}
	body()
	{	
		ag.steps++;
		@test(ev.recursive > 0,null);
        ag.writeLog("ConstructivePlan: Moving block "+first.getValue()+" onto block "+second.getValue());
		order.add(first.getValue(),second.getValue());
		@subtask(ue.update());
		@subtask(pe.print());
		if(ag.goalsRemaining() > 0)
		{
			@subtask(me.move(ev.recursive-1));
		}

	}
	boolean assign1()
	{
		thisState = 1;
		return true;
	}
	boolean assign2()
	{
		thisState = 2;
		return true;
	}
	#reasoning method 
	stateTest()
	{
 		/* Should come here only if the context is true */
		thisState = 1;

		/* If the MOVE precondition also holds then state is 2*/
		if(       
		mv.get(a,first) && mv.get(b,second) &&          // find two free blocks
        !first.getValue().equals(second.getValue()) &&  // that are unique
        !first.getValue().equals("table") &&            // and not references to
        !second.getValue().equals("table")             // the table itself) // prevent moving a block on the table to another place on the table
		) {
			thisState = 2;
		}
		return true;
	}

	#reasoning method 
	pass()
	{
        ag.record(pid, true, ag.records[ev.recursive], ev.recursive);
		//ag.records[ev.recursive] = "000"; // add to the record that the process is successful 
	}
	
	#reasoning method
	fail()
	{
        ag.record(pid, true, ag.records[ev.recursive], ev.recursive);
        //ag.writeLog("false Failed.");	
	}
}

