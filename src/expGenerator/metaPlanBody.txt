	  
	switch(ag.env.plan_selection){
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	case 1:	    //case ag.env.RND_PS:
	    int num=0,numLikely=0;
	    for (Signature s = pc.applicable.first();
		 s != null;
		 s = pc.applicable.next(s)){
		 	if (s.getInfo() instanceof PlanIdInfo){
				PlanIdInfo info = (PlanIdInfo) s.getInfo();
		 		//System.out.println("[" +num+"]: plan " + info.plan_id
				//		   +" "+ info.pSuccess);
				if (info.pSuccess>0.5){
				    numLikely++;
				}
		 	}
		num++;
	    }
	    if (numLikely >0){
		int[] likely = new int[numLikely];
		int index=0;
		Signature s = pc.applicable.first();
		for (int i=0;i<num;i++){
		    if (s.getInfo() instanceof PlanIdInfo){
			PlanIdInfo info = (PlanIdInfo) s.getInfo();
			if (info.pSuccess>0.5){
			    likely[index]= i;
			    index++;
			}
		    }
		    s = pc.applicable.next(s);
		}
		int choice = ag.generator.nextInt(numLikely);
		choice = likely[choice];
		//System.out.println(" - > choice = " + choice);
		s = pc.applicable.first();
		for (int i=0;i<choice;i++){
		    s = pc.applicable.next(s);
		}
		pc.chosen =  s;
	    }
	    else{
	    System.out.println("No plan has a frequency of success more than .5!"
	    	+"\t choose the max");
	    	// randomize max
	    int num=0;
	    for (Signature s = pc.applicable.first();
		 s != null;
		 s = pc.applicable.next(s))
		num++;
	    if (num >0){
		double[] prob = new double[num];
		int[] order = new int[num]; // array of index to randomize the order that will be used to search the max
		Signature s = pc.applicable.first();
		for (int i=0;i<num;i++){
		    if (s.getInfo() instanceof PlanIdInfo){
			PlanIdInfo info = (PlanIdInfo) s.getInfo();
			prob[i]= info.pSuccess;
			order[i]=i;
			//System.out.println("[" +i+"]: plan " + info.plan_id
			//		   +" "+ info.pSuccess);

			s = pc.applicable.next(s);
		    }
		}
		int chosen=0;
		double probMax = 0;
		int last = num;
		for (int i=0;i<num;i++){
		    int index = ag.generator.nextInt(last);
		    //System.out.print(" next: "+ order[index] +" (p=" + prob[order[index]] + ")");
		    if ( prob[order[index]] > probMax){
			probMax = prob[order[index]];
			chosen= order[index];
		    }
		    int temp = order[last-1];
		    order[last-1]= order[index];
		    order[index]=temp;
		    last--;
		}
		//System.out.print("\t@@@> chooses index "+ chosen+"\t order:"); 
		//for (int i=0;i<num;i++)
		//    System.out.print(order[i]+" ");
		s = pc.applicable.first();
		for (int i=0;i<chosen;i++){
		    s = pc.applicable.next(s);
		}
		pc.chosen =  s;
		}
	    }
	    break;
 	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	case 2:	    //case ag.env.MAX_PS:
		// randomize max
	    int num=0;
	    for (Signature s = pc.applicable.first();
		 s != null;
		 s = pc.applicable.next(s))
		num++;
	    if (num >0){
		double[] prob = new double[num];
		int[] order = new int[num]; // array of index to randomize the order that will be used to search the max
		Signature s = pc.applicable.first();
		for (int i=0;i<num;i++){
		    if (s.getInfo() instanceof PlanIdInfo){
			PlanIdInfo info = (PlanIdInfo) s.getInfo();
			prob[i]= info.pSuccess;
			order[i]=i;
			//System.out.println("[" +i+"]: plan " + info.plan_id
			//		   +" "+ info.pSuccess);

			s = pc.applicable.next(s);
		    }
		}
		int chosen=0;
		double probMax = 0;
		int last = num;
		for (int i=0;i<num;i++){
		    int index = ag.generator.nextInt(last);
		    //System.out.print(" next: "+ order[index] +" (p=" + prob[order[index]] + ")");
		    if ( prob[order[index]] > probMax){
			probMax = prob[order[index]];
			chosen= order[index];
		    }
		    int temp = order[last-1];
		    order[last-1]= order[index];
		    order[index]=temp;
		    last--;
		}
		//System.out.print("\t@@@> chooses index "+ chosen+"\t order:"); 
		//for (int i=0;i<num;i++)
		//    System.out.print(order[i]+" ");
		s = pc.applicable.first();
		for (int i=0;i<chosen;i++){
		    s = pc.applicable.next(s);
		}
		pc.chosen =  s;
		}
		break;
	//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	case 3:     //case ag.env.PROBABILISTIC_PS:
        int num=0;
        int numSuccess = 0;
        double mass;
        double max = 0;
        int POWER = 3;
        if (ag.env.update_mode==ag.env.STABLE_U) {
            for (Signature s = pc.applicable.first(); s != null; s = pc.applicable.next(s)){
                if (s.getInfo() instanceof PlanIdInfo){
                    PlanIdInfo info = (PlanIdInfo) s.getInfo();
                    if (info.pSuccess > max) {
                        max = info.pSuccess;
                    }
                }
            }
        }
        for (Signature s = pc.applicable.first(); s != null; s = pc.applicable.next(s)){
            if (s.getInfo() instanceof PlanIdInfo){
                if (ag.env.update_mode==ag.env.STABLE_U) {
                    PlanIdInfo info = (PlanIdInfo) s.getInfo();
                    if (info.pSuccess < 0.0001 ) {
                        mass += 0.0001;
                    } else if (info.pSuccess==max){
                        numSuccess++;
                    } else {
                        mass += Math.pow(info.pSuccess/max,POWER);
                    }
                } else {
                    PlanIdInfo info = (PlanIdInfo) s.getInfo();
                    if (info.pSuccess < 0.0001 ) {
                        mass += 0.0001;
                    } else {
                        mass += info.pSuccess;
                    }
                }
            }
            num++;
        }
        if (num >0){
            if (ag.env.update_mode==ag.env.STABLE_U) {
                mass += num*numSuccess;
            }
            double[] prob = new double[num];
            double acc=0;
            int i;
            String str="";
            for (Signature s = pc.applicable.first(); s != null; s = pc.applicable.next(s),i++){
                str="MetaPlan: At iteration "+ag.env.it+", the probability for plan at index "+i+" ";
                if (s.getInfo() instanceof PlanIdInfo){
                    PlanIdInfo info = (PlanIdInfo) s.getInfo();
                    str +="("+ag.planNodes[info.plan_id].getItem()+") for state "+ag.planNodes[info.plan_id].stringOfLastState()+" is ";
                    if (ag.env.update_mode==ag.env.STABLE_U) {
                        if (info.pSuccess < 0.0001) {
                            str += "0.0001/"+mass;
                            acc += 0.0001/mass;
                        } else if (info.pSuccess==max){
                            str += num+"/"+mass;
                            acc += num/mass;
                        } else {
                            str += (info.pSuccess/max)+"^"+POWER+"/"+mass;
                            acc += Math.pow(info.pSuccess/max,POWER)/mass;
                        }
                    } else {
                        if (info.pSuccess < 0.0001) {
                            str += "0.0001/"+mass;
                            acc += 0.0001/mass;
                        } else {
                            str += info.pSuccess+"/"+mass;
                            acc += (info.pSuccess)/mass;
                        }
                    }
                    prob[i] = acc;
                } else {
                    str +="(unknown) is 1.0/"+num;
                    prob[i] = 1.0/num;
                }
                ag.writeLog(str,"Stability-Updates");
            }
            double rnd = ag.generator.nextDouble();
            int choice = 0;
            while (prob[choice]<rnd){
                choice++;
            }
            str="[";
            for (i=0;i<num;i++) {
                str+= " "+ ((double)((int)(prob[i]*10000)))/10000;
            }
            str += " ]";
            ag.writeLog("MetaPlan: Choosing from applicable plans with cumulative probabilities "+str+". Chosen plan index "+choice,"Stability-Updates");
            Signature s = pc.applicable.first();
            for (i=0;i<choice;i++){
                s = pc.applicable.next(s);
            }
            pc.chosen =  s;
        }
	    break;

	    //~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
	case 4:	    //case ag.env.NO_DT_PS:
	    int num=0;
	    for (Signature s = pc.applicable.first();
		 s != null;
		 s = pc.applicable.next(s)){
		num++;
	    }
	    if (num >0){
		int choice = ag.generator.nextInt(num);
		Signature s = pc.applicable.first();
		for (int i=0;i<choice;i++){
		    s = pc.applicable.next(s);
		}
		pc.chosen =  s;
	    }
	    break;
	}
