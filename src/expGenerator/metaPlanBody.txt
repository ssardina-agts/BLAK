{
    switch (ag.env.plan_selection) {
    case 1:			/* ~~~~~~~~~ case ag.env.RND_PS */
	int num = 0, numLikely = 0;
	for (Signature s = pc.applicable.first();
	     s != null;
	     s = pc.applicable.next(s)) {
	    if (s.getInfo() instanceof PlanIdInfo) {
		PlanIdInfo info = (PlanIdInfo) s.getInfo();
		if (info.pSuccess > 0.5) {
		    numLikely++;
		}
	    }
	    num++;
	}
	if (numLikely > 0) {
	    int[] likely = new int[numLikely];
	    int index = 0;
	    Signature s = pc.applicable.first();
	    for (int i = 0; i < num; i++) {
		if (s.getInfo() instanceof PlanIdInfo) {
		    PlanIdInfo info = (PlanIdInfo) s.getInfo();
		    if (info.pSuccess > 0.5) {
			likely[index] = i;
			index++;
		    }
		}
		s = pc.applicable.next(s);
	    }
	    int choice = ag.generator.nextInt(numLikely);
	    choice = likely[choice];
	    s = pc.applicable.first();
	    for (int i = 0; i < choice; i++) {
		s = pc.applicable.next(s);
	    }
	    pc.chosen = s;
	} else {
	    System.out.println("No plan has a frequency of success more than .5!" +
			       "\t choose the max");
	    /* randomize max */
	    int num = 0;
	    for (Signature s = pc.applicable.first();
		 s != null;
		 s = pc.applicable.next(s))
		num++;
	    if (num > 0) {
		double[] prob = new double[num];
		/* array of index to randomize the order that will be used to
		 * search the max */
		int[] order = new int[num];
		Signature s = pc.applicable.first();
		for (int i = 0; i < num; i++) {
		    if (s.getInfo() instanceof PlanIdInfo) {
			PlanIdInfo info = (PlanIdInfo) s.getInfo();
			prob[i] = info.pSuccess;
			order[i] = i;

			s = pc.applicable.next(s);
		    }
		}
		int chosen = 0;
		double probMax = 0;
		int last = num;
		for (int i = 0; i < num; i++) {
		    int index = ag.generator.nextInt(last);
		    if (prob[order[index]] > probMax) {
			probMax = prob[order[index]];
			chosen = order[index];
		    }
		    int temp = order[last - 1];
		    order[last - 1] = order[index];
		    order[index] = temp;
		    last--;
		}
		s = pc.applicable.first();
		for (int i = 0; i < chosen; i++) {
		    s = pc.applicable.next(s);
		}
		pc.chosen = s;
	    }
	}
	break;

    case 2:			/* ~~~~~~~~~ case ag.env.MAX_PS */
	/* randomize max */
	int num = 0;
	for (Signature s = pc.applicable.first();
	     s != null;
	     s = pc.applicable.next(s))
	    num++;
	if (num > 0) {
	    double[] prob = new double[num];
	    /* array of index to randomize the order that will be used to
	     * search the max */
	    int[] order = new int[num];
	    Signature s = pc.applicable.first();
	    for (int i = 0; i < num; i++) {
		if (s.getInfo() instanceof PlanIdInfo) {
		    PlanIdInfo info = (PlanIdInfo) s.getInfo();
		    prob[i] = info.pSuccess;
		    order[i] = i;
		    s = pc.applicable.next(s);
		}
	    }
	    int chosen = 0;
	    double probMax = 0;
	    int last = num;
	    for (int i = 0; i < num; i++) {
		int index = ag.generator.nextInt(last);
		if (prob[order[index]] > probMax) {
		    probMax = prob[order[index]];
		    chosen = order[index];
		}
		int temp = order[last - 1];
		order[last - 1] = order[index];
		order[index] = temp;
		last--;
	    }
	    s = pc.applicable.first();
	    for (int i = 0; i < chosen; i++) {
		s = pc.applicable.next(s);
	    }
	    pc.chosen = s;
	}
	break;

    case 3:			/* ~~~~~~~~~ case ag.env.COVERAGE_PS */
    case 4:			/* ~~~~~~~~~ case ag.env.PROBABILISTIC_PS */
	int num = 0;
	double mass;
	int POWER = 1;
	Signature thandler = null;
	double pMax = -1.0;
	int pMaxId;
	for (Signature s = pc.applicable.first(); s != null; s = pc.applicable.next(s)) {
	    if (s.getInfo() instanceof PlanIdInfo) {
		PlanIdInfo info = (PlanIdInfo) s.getInfo();
		if (info.isFailedThresholdHandler) {
		    thandler = s;
		} else {
		    double p = info.pSuccess;
		    if (ag.env.plan_selection == ag.env.COVERAGE_PS) {
			p = 0.5 + (info.coverage * (p - 0.5));
			String str =
			"Plan " + ag.planNodes[info.plan_id].getItem() +
			" REVISED the probability in state " + ag.planNodes[info.plan_id].stringOfLastState() +
			" to p=" + ((double) ((int) (p * 10000))) / 10000 +
			" based on coverage c=" + ((double) ((int) (info.coverage * 10000))) / 10000;
			ag.env.writeLog(str);
		    }
		    if (p < 0.0001) {
			mass += 0.0001;
		    } else {
			mass += Math.pow(p, POWER);
		    }
		    if (p > pMax) {
			pMax = p;
			pMaxId = info.plan_id;
		    }
		}
	    }
	    num++;
	}

	/* If pMax is less than the threshold and not a leaf plan then always select the failed threshold handler plan */
	if ((pMax < ag.planSelectThreshold) && (thandler != null) && (ag.planNodes[pMaxId].getNumberOfChildren() > 0) ) {
	    pc.chosen = thandler;
	    ag.env.writeLog("MetaPlan: Using failed threshold plan since " +
		"p("+(((double) ((int) (pMax * 10000))) / 10000)+")<threshold("+
		(((double) ((int) (ag.planSelectThreshold * 10000))) / 10000)+")");
	} else {
	if (num > 0) {
	    double[] prob = new double[num];
	    double acc = 0;
	    int i;
	    String str = "";
	    for (Signature s = pc.applicable.first(); s != null; s = pc.applicable.next(s), i++) {
		if (s.getInfo() instanceof PlanIdInfo) {
		    str = "MetaPlan: At iteration " + ag.env.it +
			", the probability for plan at index " + i + " ";
		    PlanIdInfo info = (PlanIdInfo) s.getInfo();
		    if (!info.isFailedThresholdHandler) {
			double p = info.pSuccess;
			if (ag.env.plan_selection == ag.env.COVERAGE_PS) {
			    p = 0.5 + (info.coverage * (p - 0.5));
			}
			str += "(" + ag.planNodes[info.plan_id].getItem() + ") for state " +
			    ag.planNodes[info.plan_id].stringOfLastState() + " is ";
			if (p < 0.0001) {
			    str += "0.0001/" + mass;
			    acc += 0.0001 / mass;
			} else {
			    str += p + "^" + POWER + "/" + mass;
			    acc += Math.pow(p, POWER) / mass;
			}
			prob[i] = acc;
		    }
		} else {
		    str += "(unknown) is 1.0/" + num;
		    prob[i] = 1.0 / num;
		}
		ag.env.writeLog(str);
	    }
	    double rnd = ag.generator.nextDouble();
	    int choice = 0;
	    while (prob[choice] < rnd) {
		choice++;
	    }
	    str = "[";
	    for (i = 0; i < num; i++) {
		str += " " + ((double) ((int) (prob[i] * 10000))) / 10000;
	    }
	    str += " ]";
	    ag.env.writeLog("MetaPlan: Choosing from applicable plans with cumulative probabilities " +
			    str + ". Chosen plan index " + choice);
	    Signature s = pc.applicable.first();
	    for (i = 0; i < choice; i++) {
		s = pc.applicable.next(s);
	    }
	    pc.chosen = s;
	}
	}
	break;

    case 5:			/* ~~~~~~~~~ case ag.env.NO_DT_PS */
	int num = 0;
	for (Signature s = pc.applicable.first();
	     s != null;
	     s = pc.applicable.next(s)) {
	    num++;
	}
	if (num > 0) {
	    int choice = ag.generator.nextInt(num);
	    Signature s = pc.applicable.first();
	    for (int i = 0; i < choice; i++) {
		s = pc.applicable.next(s);
	    }
	    pc.chosen = s;
	}
	break;
    }
}
