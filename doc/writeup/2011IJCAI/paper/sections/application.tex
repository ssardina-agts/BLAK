%!TEX root = ../ijcai11storage.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{An Embedded Battery System Controller}\label{sec:application}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\aSet}{\mathname{set}}
\newcommand{\aOperate}{\mathname{operate}}
\newcommand{\aEvaluate}{\mathname{evaluate}}

\newcommand{\pSet}{\mathname{Set*}}
\newcommand{\pSetCharge}{\mathname{SetCharge}}
\newcommand{\pSetDischarge}{\mathname{SetDischarge}}
\newcommand{\pSetNotUsed}{\mathname{SetNotUsed}}
\newcommand{\pExecute}{\mathname{Execute}}

\newcommand{\cSatisfies}{\psi}

\input{figs/fig-experiments}

Energy storage enables increasing levels of renewable energy in our electricity system, and the rapidly maturing supply chains for several battery technologies encourages electricity utilities, generators, and customers to consider using large battery systems. 
%
Such systems usually comprise of multiple modules that can be controlled independently~\cite{norris02:grid}. Often it is necessary to operate the modules in different states, such as if it is undesirable to change the direction of power flow too frequently, or due to battery technology requirements such as zinc-bromine flow batteries needing complete discharges at regular intervals. Since battery performance is susceptible to changes over time (e.g. modules tend to lose actual capacity) an \emph{adaptable} control mechanism is desirable that accounts for such drift.
%
Here, we describe the implementation of an {\em adaptive embedded BDI controller for a modular battery system}, that regulates overall energy consumption of a smart office building comprising of loads (e.g., appliances) and generators (e.g. solar panels), by suitably ordering the battery installation (i.e. each module in the battery: the overall rate being the sum over the modules' rates) to charge (i.e., act as a load) or discharge (i.e., act as a generator) at determined rates.

Figure~\ref{fig:gptree} shows our implemented controller for an overall system capacity of $c \times k$, where $c$ is the capacity of each module (albeit with different chemical properties and constraints) and $k$ is the total number of modules in the system. Top-level goal-event $G(r,k,s)$ requests a battery charge/discharge (normalized) rate of $r \in [-1.0:+1.0]$, where $-1.0$ ($1.0$) indicates maximum discharge (charge) rate, $s$ stands for the current state of the battery system as per sensor readings, and $k$ is (initially) the number of modules in the system. 
%%
The BDI controller works by recursively configuring each module for the period in question using the plans $\pSetCharge$ (charging at rate $+c$), $\pSetDischarge$ (discharging at rate $-c$), and $\pSetNotUsed$ (disconnected i.e. rate $0$), and finally, after all modules have been configured, physically operating the battery for one period using the $\pExecute$ plan. 
%%

Observe that the first three plans already contain initially known domain constraints for applicability using condition $\cSatisfies_X(\cdot,\cdot,\cdot)$. For instance, plan $\pSetCharge$ may not be considered if the module is already charged, or $\pSetDischarge$ may be ruled out because discharging the module implies that regardless of how the remaining modules are configured, the response is bound to fall short of the request. When none of the first three plans apply for a given module, then BDI failure recovery may be employed to backtrack up and select a different configuration path until all constraints are satisfied or all options exhausted. 

As such, the $\pExecute$ plan is run only with configurations that are functionally correct. This involves first operating the whole battery system for the period ($\aOperate$) and then evaluating the result via a sensor ($\aEvaluate$). If the evaluation \emph{succeeds}, then the desired overall rate $r$ has been met and the whole execution is deemed successful. Otherwise, the evaluation step \emph{fails} and so does the whole execution of the program, since no BDI failure recovery can be used after the battery system has been physically operated. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Experimental Results}\label{sec:results}

The following setup applies to all experiments for a battery system with \emph{five} modules (i.e., $k=5$). For each module, the current charge state is described by a discrete value in the range $[0:3]$, where zero indicates a fully discharged state and three indicates a fully charged state. In addition, each module has an assigned configuration for the current period from the set $\{+c, 0, -c\}$, where $c=1/k$. The operational model is simple: charging is meant to add $+c$ while discharging is meant to add $-c$ to a module's charge state, otherwise the state is unchanged for the period (i.e., there is no charge loss). Thus, the desired overall battery response is in the (normalized) range $[-1.0:+1.0]$ in discrete intervals of $\pm c$. The complete state space for the problem is described by the number of modules ($5$), the possible requests ($11$), the charge state of the system ($4^5$), and the assigned configuration of the system ($3^5$), that is, $5 \times 11 \times 4^5 \times 3^5 \approx 13.7$ million states. Though significant, note that the agent does not have to learn over this space, because the filtering of nonsensical configurations by the plans' context conditions $\cSatisfies_X(\cdot,\cdot,\cdot)$ will reduce it substantially.
%
Each episode corresponds to one $G(r,5,s)$ goal-event request: achieve overall battery response of $r$ given current module charge states $s$.  For simplicity of analysis, we assume only satisfiable requests: a solution always exists. The outcome of each episode is either no response (no configuration was executed), or a single invocation of the $\pExecute$ plan for operating (and evaluating) the battery. The threshold parameter for stability calculation is set to $0.5$. We use an averaging window of $n=5$ for both the stability-based metric $\C_s(\cdot,\cdot,n)$ and the world-based metric $\C_d(\cdot,n)$, and a (balanced) weighting of $\alpha=0.5$ for the final confidence measure $\C(\cdot,\cdot,\cdot)$. Each experiment is run five times and the reported results are averages from these runs. Finally, 
%
In normal BDI operation, only plans that are deemed applicable as per their context condition are considered for execution. For our learning framework, where applicability is additionally defined by a plan's decision tree, this means that only plans with a reasonable likelihood of success should be allowed. To represent this, we used an \emph{applicability threshold} for plan selection of $40\%$, meaning that plans with a likelihood of success below this value are removed from consideration.\footnote{While this feature {\em does not alter the overall learning performance} of the battery controller, it does preclude the battery from being operated (i.e., plan $\pExecute$ being called) under module configurations that are likely to be unsuccessful. In fact, we found that the threshold used reduces the number of battery operations by $12\%$, which is substantial when considering battery life.}



%
The first experiment (Figure~\ref{fig:experiment1}) represents a typical (one-f) learning setting where the agent recovers functionality against deterioration in module capacities. Typically this would occur over years of use, however to show the response to substantial change, we force this deterioration to occur instantaneously (at around $5\kilo$ episodes). The resulting rapid drop in performance (to $\approx 76\%$ success) corresponding to the set of programmed/learnt solutions that no longer work, is subsequently rectified by the controller by learning to avoid the module configurations that no longer work. 

Our next two experiments were aimed at demonstrating the adaptive behaviour when the environment dynamics is continually changing.
%
In experiment two (Figure~\ref{fig:experiment2}), the agent is exposed to partial failures of the system caused by modules malfunctioning (the first battery module fails for the duration $[0:20\kilo]$ after which it is reinstated, the second for the period $[20\kilo:40\kilo]$, and so on), but the battery always remains capable of successfully responding to the request using alternative configurations. Following each module failure, the system successfully learns to operate the battery without it, by always configuring the failed module to not-in-use (i.e., state $0$).~\footnote{The apparent difference between performance drops at $0\kilo$ and $20\kilo$ is not meaningful in any way; it just happens that more ``bad'' cases occurred in the first failure.} 
%
In the final experiment (Figure~\ref{fig:experiment3}), we analyse the controller response in the extreme case where the system suffers complete failure (for the period $[0:5\kilo]$) and is thereafter restored.~\footnote{Here (at around $2\kilo$ episodes), the estimated likelihood of success of all plans drops below the applicability threshold of $40\%$. This would means that no plans are ever applicable and plan $\pExecute$ is never invoked. To address this, we use as a ``soft'' applicability threshold mechanism: the $40\%$ threshold applies $90\%$ of the time.}
